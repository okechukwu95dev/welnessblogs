// Must be at the very top, before any imports
jest.mock('@/main/components/ExportMenu/exportFunctions');

import {
  fetchData,
  fetchAndLogExports,
  downloadFile,
  handleStagedExportDownload,
  handleReleaseExport,
  handleLatestStagedExportDownload,
  handleReleasedExportDownload
} from '@/main/components/ExportMenu/exportFunctions';

// Mock dependencies
jest.mock('@/main/utility/FilenameUtils', () => ({
  generateExportFilename: jest.fn().mockImplementation((exportData, stage) => 
    `export-${exportData.id}-${stage}.zip`)
}));

// Mock document and URL
const mockAnchor = {
  href: '',
  download: '',
  click: jest.fn()
};

Object.defineProperty(global, 'document', {
  value: {
    createElement: jest.fn().mockReturnValue(mockAnchor),
    body: {
      appendChild: jest.fn(),
      removeChild: jest.fn()
    }
  },
  writable: true
});

global.URL.createObjectURL = jest.fn().mockReturnValue('blob:mock-url');

// Type assertions for mocks
const mockedFetchData = fetchData as jest.Mock;
const mockedFetchAndLogExports = fetchAndLogExports as jest.Mock;
const mockedDownloadFile = downloadFile as jest.Mock;
const mockedHandleStagedExportDownload = handleStagedExportDownload as jest.Mock;
const mockedHandleReleaseExport = handleReleaseExport as jest.Mock;
const mockedHandleLatestStagedExportDownload = handleLatestStagedExportDownload as jest.Mock;
const mockedHandleReleasedExportDownload = handleReleasedExportDownload as jest.Mock;

describe('Export Functions', () => {
  let mockClient;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create a mock client for all tests
    mockClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn()
    };
  });
  
  describe('fetchData', () => {
    it('should fetch data from URL and return results', async () => {
      // Setup
      const mockResponse = { 
        data: { 
          results: [{ id: 1 }, { id: 2 }],
          next: null 
        } 
      };
      mockClient.get.mockResolvedValue(mockResponse);
      
      // Provide implementation for this test
      mockedFetchData.mockImplementation(async (client, url) => {
        const response = await client.get(url);
        return response.data.results;
      });
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/test-url');
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle paginated data', async () => {
      // Setup
      const mockResponse1 = { 
        data: { 
          results: [{ id: 1 }],
          next: '/next-page' 
        } 
      };
      const mockResponse2 = { 
        data: { 
          results: [{ id: 2 }],
          next: null 
        } 
      };
      
      mockClient.get.mockImplementation((url) => {
        if (url === '/test-url') return Promise.resolve(mockResponse1);
        if (url === '/next-page') return Promise.resolve(mockResponse2);
        return Promise.reject(new Error('Unexpected URL'));
      });
      
      // Custom implementation for paginated data test
      mockedFetchData.mockImplementation(async (client, url) => {
        let currentUrl = url;
        let allResults = [];
        
        while (currentUrl) {
          const response = await client.get(currentUrl);
          allResults = [...allResults, ...response.data.results];
          currentUrl = response.data.next;
        }
        
        return allResults;
      });
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledTimes(2);
      expect(mockClient.get).toHaveBeenCalledWith('/test-url');
      expect(mockClient.get).toHaveBeenCalledWith('/next-page');
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
  });
  
  describe('fetchAndLogExports', () => {
    it('should fetch and filter exports', async () => {
      // Setup
      const mockResults = [
        { id: 1, exportPhase: 'STAGING' },
        { id: 2, exportPhase: 'RELEASE' },
        { id: 3, exportPhase: 'STAGING' }
      ];
      
      // Mock fetchData just for this test
      mockedFetchData.mockResolvedValue(mockResults);
      
      // Implementation for fetchAndLogExports
      mockedFetchAndLogExports.mockImplementation(async (client) => {
        const results = await fetchData(client, '/export-artifact/?limit=50');
        
        const stagedExports = results.filter(item => item.exportPhase === 'STAGING');
        const releasedExports = results.filter(item => item.exportPhase === 'RELEASE');
        
        return {
          latestStagedExport: stagedExports.length > 0 ? stagedExports[stagedExports.length - 1] : null,
          latestReleasedExport: releasedExports.length > 0 ? releasedExports[releasedExports.length - 1] : null
        };
      });
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(fetchData).toHaveBeenCalledWith(mockClient, '/export-artifact/?limit=50');
      expect(result).toEqual({
        latestStagedExport: { id: 3, exportPhase: 'STAGING' },
        latestReleasedExport: { id: 2, exportPhase: 'RELEASE' }
      });
    });
    
    it('should handle empty results', async () => {
      // Setup
      mockedFetchData.mockResolvedValue([]);
      
      // Implementation for empty results
      mockedFetchAndLogExports.mockImplementation(async (client) => {
        const results = await fetchData(client, '/export-artifact/?limit=50');
        return {
          latestStagedExport: null,
          latestReleasedExport: null
        };
      });
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(result).toEqual({
        latestStagedExport: null,
        latestReleasedExport: null
      });
    });
  });
  
  describe('downloadFile', () => {
    it('should download a file', async () => {
      // Setup
      const mockExportData = { id: 1, artifactSource: 'test-source' };
      const blob = new Blob(['test'], { type: 'application/zip' });
      mockClient.get.mockResolvedValue({ data: blob });
      
      // Implementation for downloadFile
      mockedDownloadFile.mockImplementation(async (client, artifactSource, exportData, stage) => {
        try {
          const url = `/export-artifact/${artifactSource}/download/`;
          const response = await client.get(url, { responseType: 'blob' });
          
          const link = document.createElement('a');
          link.href = URL.createObjectURL(response.data);
          link.download = `export-${exportData.id}-${stage}.zip`;
          link.click();
          
          document.body.appendChild(link);
          document.body.removeChild(link);
        } catch (error) {
          console.error('Error downloading file:', error);
        }
      });
      
      // Execute
      await downloadFile(mockClient, 'test-source', mockExportData, 'RELEASE');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/export-artifact/test-source/download/', { responseType: 'blob' });
      expect(document.createElement).toHaveBeenCalled();
      expect(URL.createObjectURL).toHaveBeenCalledWith(blob);
      expect(mockAnchor.click).toHaveBeenCalled();
    });
  });
  
  describe('handleStagedExportDownload', () => {
    it('should post to /export/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Staged' } };
      mockClient.post.mockResolvedValue(mockResponse);
      
      // Implementation for handleStagedExportDownload
      mockedHandleStagedExportDownload.mockImplementation(async (client) => {
        try {
          const response = await client.post('/export/');
          return response.data;
        } catch (error) {
          console.error('Error staging export:', error);
        }
      });
      
      // Execute
      const result = await handleStagedExportDownload(mockClient);
      
      // Verify
      expect(mockClient.post).toHaveBeenCalledWith('/export/');
      expect(result).toEqual({ id: 1, status: 'Staged' });
    });
  });
  
  describe('handleReleaseExport', () => {
    it('should put to /export/{id}/release/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Released' } };
      mockClient.put.mockResolvedValue(mockResponse);
      
      // Implementation for handleReleaseExport
      mockedHandleReleaseExport.mockImplementation(async (client, id) => {
        try {
          const response = await client.put(`/export/${id}/release/`);
          return response.data;
        } catch (error) {
          console.error('Error releasing export:', error);
        }
      });
      
      // Execute
      const result = await handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(mockClient.put).toHaveBeenCalledWith('/export/1/release/');
      expect(result).toEqual({ id: 1, status: 'Released' });
    });
  });
  
  describe('handleLatestStagedExportDownload', () => {
    it('should download the latest staged export', async () => {
      // Setup
      const latestStagedExport = { 
        id: 1, 
        artifactSource: 'test-source',
        exportPhase: 'STAGING'
      };
      
      // Mock dependencies
      mockedFetchAndLogExports.mockResolvedValue({
        latestStagedExport,
        latestReleasedExport: null
      });
      
      mockedDownloadFile.mockResolvedValue(undefined);
      
      // Implementation for handleLatestStagedExportDownload
      mockedHandleLatestStagedExportDownload.mockImplementation(async (client) => {
        const { latestStagedExport } = await fetchAndLogExports(client);
        
        if (latestStagedExport) {
          await downloadFile(client, latestStagedExport.id, latestStagedExport, 'STAGED');
        } else {
          console.log('No Staged Exports available for download.');
        }
      });
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(downloadFile).toHaveBeenCalledWith(
        mockClient, 
        latestStagedExport.id, 
        latestStagedExport, 
        'STAGED'
      );
    });
    
    it('should handle case with no staged exports', async () => {
      // Setup
      mockedFetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalledWith('No Staged Exports available for download.');
      expect(downloadFile).not.toHaveBeenCalled();
    });
  });
  
  describe('handleReleasedExportDownload', () => {
    it('should download the latest released export', async () => {
      // Setup
      const latestReleasedExport = { 
        id: 2, 
        artifactSource: 'test-source',
        exportPhase: 'RELEASE'
      };
      
      // Mock dependencies
      mockedFetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport
      });
      
      mockedDownloadFile.mockResolvedValue(undefined);
      
      // Implementation for handleReleasedExportDownload
      mockedHandleReleasedExportDownload.mockImplementation(async (client) => {
        const { latestReleasedExport } = await fetchAndLogExports(client);
        
        if (latestReleasedExport) {
          await downloadFile(
            client, 
            latestReleasedExport.artifactSource, 
            latestReleasedExport, 
            'RELEASE'
          );
        } else {
          console.log('No Released Export available for download.');
        }
      });
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(downloadFile).toHaveBeenCalledWith(
        mockClient, 
        latestReleasedExport.artifactSource, 
        latestReleasedExport, 
        'RELEASE'
      );
    });
    
    it('should handle case with no released exports', async () => {
      // Setup
      mockedFetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalledWith('No Released Export available for download.');
      expect(downloadFile).not.toHaveBeenCalled();
    });
  });
});