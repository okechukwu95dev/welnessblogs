import * as exportFunctions from '@/main/components/ExportMenu/exportFunctions';

// Create spies directly on the imported module
jest.spyOn(exportFunctions, 'fetchData');
jest.spyOn(exportFunctions, 'fetchAndLogExports');
jest.spyOn(exportFunctions, 'downloadFile');

// Mock dependencies with proper TypeScript signatures
jest.mock('@/main/utility/FilenameUtils', () => ({
  generateExportFilename: jest.fn().mockImplementation((exportData, stage) => 
    `export-${exportData.id}-${stage}.zip`)
}));

// Set up document mock
const originalDocument = { ...global.document };
const mockAnchor = {
  href: '',
  download: '',
  click: jest.fn()
};

Object.defineProperty(global, 'document', {
  value: {
    ...originalDocument,
    createElement: jest.fn().mockReturnValue(mockAnchor),
    body: {
      appendChild: jest.fn(),
      removeChild: jest.fn()
    }
  },
  writable: true
});

// Mock URL.createObjectURL
global.URL.createObjectURL = jest.fn().mockReturnValue('blob:mock-url');

describe('Export Functions', () => {
  let mockClient;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create a mock client for all tests
    mockClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn()
    };
  });
  
  describe('fetchData', () => {
    it('should fetch data from URL and return results', async () => {
      // Setup
      const mockResponse = { 
        data: { 
          results: [{ id: 1 }, { id: 2 }],
          next: null 
        } 
      };
      mockClient.get.mockResolvedValue(mockResponse);
      
      // Execute
      const results = await exportFunctions.fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/test-url');
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle paginated data', async () => {
      // Setup
      const mockResponse1 = { 
        data: { 
          results: [{ id: 1 }],
          next: '/next-page' 
        } 
      };
      const mockResponse2 = { 
        data: { 
          results: [{ id: 2 }],
          next: null 
        } 
      };
      
      mockClient.get.mockImplementation((url) => {
        if (url === '/test-url') return Promise.resolve(mockResponse1);
        if (url === '/next-page') return Promise.resolve(mockResponse2);
        return Promise.reject(new Error('Unexpected URL'));
      });
      
      // Execute
      const results = await exportFunctions.fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledTimes(2);
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
  });
  
  describe('fetchAndLogExports', () => {
    it('should fetch and filter exports', async () => {
      // Setup
      const mockResults = [
        { id: 1, exportPhase: 'STAGING' },
        { id: 2, exportPhase: 'RELEASE' },
        { id: 3, exportPhase: 'STAGING' }
      ];
      
      // Mock fetchData directly on the module
      exportFunctions.fetchData.mockResolvedValue(mockResults);
      
      // Execute
      const result = await exportFunctions.fetchAndLogExports(mockClient);
      
      // Verify
      expect(exportFunctions.fetchData).toHaveBeenCalledWith(mockClient, '/export-artifact/?limit=50');
      expect(result).toEqual({
        latestStagedExport: { id: 3, exportPhase: 'STAGING' },
        latestReleasedExport: { id: 2, exportPhase: 'RELEASE' }
      });
    });
    
    it('should handle empty results', async () => {
      // Setup
      exportFunctions.fetchData.mockResolvedValue([]);
      
      // Execute
      const result = await exportFunctions.fetchAndLogExports(mockClient);
      
      // Verify
      expect(result).toEqual({
        latestStagedExport: null,
        latestReleasedExport: null
      });
    });
  });
  
  describe('downloadFile', () => {
    it('should download a file', async () => {
      // Setup
      const mockExportData = { id: 1, artifactSource: 'test-source' };
      const blob = new Blob(['test'], { type: 'application/zip' });
      mockClient.get.mockResolvedValue({ data: blob });
      
      // Execute
      await exportFunctions.downloadFile(mockClient, 'test-source', mockExportData, 'RELEASE');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/export-artifact/test-source/download/', { responseType: 'blob' });
      expect(document.createElement).toHaveBeenCalled();
      expect(global.URL.createObjectURL).toHaveBeenCalled();
      expect(mockAnchor.click).toHaveBeenCalled();
    });
  });
  
  describe('handleStagedExportDownload', () => {
    it('should post to /export/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Staged' } };
      mockClient.post.mockResolvedValue(mockResponse);
      
      // Execute
      const result = await exportFunctions.handleStagedExportDownload(mockClient);
      
      // Verify
      expect(mockClient.post).toHaveBeenCalledWith('/export/');
      expect(result).toEqual({ id: 1, status: 'Staged' });
    });
  });
  
  describe('handleReleaseExport', () => {
    it('should put to /export/{id}/release/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Released' } };
      mockClient.put.mockResolvedValue(mockResponse);
      
      // Execute
      const result = await exportFunctions.handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(mockClient.put).toHaveBeenCalledWith('/export/1/release/');
      expect(result).toEqual({ id: 1, status: 'Released' });
    });
  });
  
  describe('handleLatestStagedExportDownload', () => {
    it('should download the latest staged export', async () => {
      // Setup
      const latestStagedExport = { 
        id: 1, 
        artifactSource: 'test-source',
        exportPhase: 'STAGING'
      };
      
      // Mock direct dependencies
      exportFunctions.fetchAndLogExports.mockResolvedValue({
        latestStagedExport,
        latestReleasedExport: null
      });
      
      exportFunctions.downloadFile.mockResolvedValue();
      
      // Execute
      await exportFunctions.handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(exportFunctions.fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(exportFunctions.downloadFile).toHaveBeenCalledWith(
        mockClient, 
        latestStagedExport.id, 
        latestStagedExport, 
        'STAGED'
      );
    });
    
    it('should handle case with no staged exports', async () => {
      // Setup
      exportFunctions.fetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await exportFunctions.handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalledWith('No Staged Exports available for download.');
      expect(exportFunctions.downloadFile).not.toHaveBeenCalled();
    });
  });
  
  describe('handleReleasedExportDownload', () => {
    it('should download the latest released export', async () => {
      // Setup
      const latestReleasedExport = { 
        id: 2, 
        artifactSource: 'test-source',
        exportPhase: 'RELEASE'
      };
      
      // Mock dependencies
      exportFunctions.fetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport
      });
      
      exportFunctions.downloadFile.mockResolvedValue();
      
      // Execute
      await exportFunctions.handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(exportFunctions.fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(exportFunctions.downloadFile).toHaveBeenCalledWith(
        mockClient, 
        latestReleasedExport.artifactSource, 
        latestReleasedExport, 
        'RELEASE'
      );
    });
    
    it('should handle case with no released exports', async () => {
      // Setup
      exportFunctions.fetchAndLogExports.mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await exportFunctions.handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalledWith('No Released Export available for download.');
      expect(exportFunctions.downloadFile).not.toHaveBeenCalled();
    });
  });
});