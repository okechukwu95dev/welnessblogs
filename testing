// This should be the ONLY module-level mock
jest.mock('@/main/utility/FilenameUtils', () => ({
  generateExportFilename: jest.fn((exportData, stage) => 
    `export-${exportData.id}-${stage}.zip`)
}));

// Import real functions - no need to mock the entire module
import {
  fetchData,
  fetchAndLogExports,
  downloadFile,
  handleStagedExportDownload,
  handleReleaseExport,
  handleLatestStagedExportDownload,
  handleReleasedExportDownload
} from '@/main/components/ExportMenu/exportFunctions';

describe('Export Functions', () => {
  let mockClient;
  let mockAnchor;
  let consoleSpy;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create a mock client for all tests
    mockClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn()
    };
    
    // Create a mock anchor only for downloadFile tests
    mockAnchor = {
      href: '',
      download: '',
      click: jest.fn()
    };
    
    // Mock only specific document methods
    jest.spyOn(document, 'createElement').mockReturnValue(mockAnchor);
    jest.spyOn(document.body, 'appendChild').mockImplementation(() => {});
    jest.spyOn(document.body, 'removeChild').mockImplementation(() => {});
    
    // Mock URL.createObjectURL
    global.URL.createObjectURL = jest.fn().mockReturnValue('blob:mock-url');
    
    // Spy on console
    consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });
  
  afterEach(() => {
    // Restore console
    consoleSpy.mockRestore();
  });
  
  describe('fetchData', () => {
    it('should fetch data from URL and return results', async () => {
      // Setup
      const mockResponse = { 
        data: { 
          results: [{ id: 1 }, { id: 2 }],
          next: null 
        } 
      };
      mockClient.get.mockResolvedValue(mockResponse);
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/test-url');
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle paginated data', async () => {
      // Setup
      const mockResponse1 = { 
        data: { 
          results: [{ id: 1 }],
          next: '/next-page' 
        } 
      };
      const mockResponse2 = { 
        data: { 
          results: [{ id: 2 }],
          next: null 
        } 
      };
      
      mockClient.get.mockImplementation((url) => {
        if (url === '/test-url') return Promise.resolve(mockResponse1);
        if (url === '/next-page') return Promise.resolve(mockResponse2);
        return Promise.reject(new Error('Unexpected URL'));
      });
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledTimes(2);
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.get.mockRejectedValue(new Error('Network error'));
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(results).toEqual([]);
      expect(console.error).toHaveBeenCalled();
    });
  });
  
  describe('fetchAndLogExports', () => {
    it('should fetch and filter exports', async () => {
      // Mock fetchData just for this test
      jest.spyOn(global, 'fetchData').mockResolvedValue([
        { id: 1, exportPhase: 'STAGING' },
        { id: 2, exportPhase: 'RELEASE' },
        { id: 3, exportPhase: 'STAGING' }
      ]);
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(fetchData).toHaveBeenCalledWith(mockClient, '/export-artifact/?limit=50');
      expect(result).toEqual({
        latestStagedExport: { id: 3, exportPhase: 'STAGING' },
        latestReleasedExport: { id: 2, exportPhase: 'RELEASE' }
      });
    });
    
    it('should handle empty results', async () => {
      // Setup
      jest.spyOn(global, 'fetchData').mockResolvedValue([]);
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(result).toEqual({
        latestStagedExport: null,
        latestReleasedExport: null
      });
    });
  });
  
  describe('downloadFile', () => {
    it('should download a file', async () => {
      // Setup
      const mockExportData = { id: 1, artifactSource: 'test-source' };
      const blob = new Blob(['test'], { type: 'application/zip' });
      mockClient.get.mockResolvedValue({ data: blob });
      
      // Execute
      await downloadFile(mockClient, 'test-source', mockExportData, 'RELEASE');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/export-artifact/test-source/download/', { responseType: 'blob' });
      expect(document.createElement).toHaveBeenCalled();
      expect(global.URL.createObjectURL).toHaveBeenCalledWith(blob);
      expect(mockAnchor.click).toHaveBeenCalled();
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.get.mockRejectedValue(new Error('Download error'));
      
      // Execute
      await downloadFile(mockClient, 'test-source', { id: 1 }, 'STAGING');
      
      // Verify
      expect(console.error).toHaveBeenCalled();
    });
  });
  
  describe('handleStagedExportDownload', () => {
    it('should post to /export/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Staged' } };
      mockClient.post.mockResolvedValue(mockResponse);
      
      // Execute
      const result = await handleStagedExportDownload(mockClient);
      
      // Verify
      expect(mockClient.post).toHaveBeenCalledWith('/export/');
      expect(result).toEqual({ id: 1, status: 'Staged' });
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.post.mockRejectedValue(new Error('Staging error'));
      
      // Execute
      await handleStagedExportDownload(mockClient);
      
      // Verify
      expect(console.error).toHaveBeenCalled();
    });
  });
  
  describe('handleReleaseExport', () => {
    it('should put to /export/{id}/release/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Released' } };
      mockClient.put.mockResolvedValue(mockResponse);
      
      // Execute
      const result = await handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(mockClient.put).toHaveBeenCalledWith('/export/1/release/');
      expect(result).toEqual({ id: 1, status: 'Released' });
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.put.mockRejectedValue(new Error('Release error'));
      
      // Execute
      await handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(console.error).toHaveBeenCalled();
    });
  });
  
  describe('handleLatestStagedExportDownload', () => {
    it('should download the latest staged export', async () => {
      // Setup
      const latestStagedExport = { 
        id: 1, 
        artifactSource: 'test-source',
        exportPhase: 'STAGING'
      };
      
      // Mock fetchAndLogExports just for this test
      jest.spyOn(global, 'fetchAndLogExports').mockResolvedValue({
        latestStagedExport,
        latestReleasedExport: null
      });
      
      // Spy on downloadFile to verify it's called
      const downloadFileSpy = jest.spyOn(global, 'downloadFile').mockResolvedValue();
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(downloadFileSpy).toHaveBeenCalledWith(
        mockClient, 
        latestStagedExport.id, 
        latestStagedExport, 
        'STAGED'
      );
    });
    
    it('should handle case with no staged exports', async () => {
      // Setup
      jest.spyOn(global, 'fetchAndLogExports').mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      // Spy on downloadFile to verify it's NOT called
      const downloadFileSpy = jest.spyOn(global, 'downloadFile');
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(console.log).toHaveBeenCalledWith('No Staged Exports available for download.');
      expect(downloadFileSpy).not.toHaveBeenCalled();
    });
  });
  
  describe('handleReleasedExportDownload', () => {
    it('should download the latest released export', async () => {
      // Setup
      const latestReleasedExport = { 
        id: 2, 
        artifactSource: 'test-source',
        exportPhase: 'RELEASE'
      };
      
      // Mock fetchAndLogExports for this test
      jest.spyOn(global, 'fetchAndLogExports').mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport
      });
      
      // Spy on downloadFile to verify it's called
      const downloadFileSpy = jest.spyOn(global, 'downloadFile').mockResolvedValue();
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(fetchAndLogExports).toHaveBeenCalledWith(mockClient);
      expect(downloadFileSpy).toHaveBeenCalledWith(
        mockClient, 
        latestReleasedExport.artifactSource, 
        latestReleasedExport, 
        'RELEASE'
      );
    });
    
    it('should handle case with no released exports', async () => {
      // Setup
      jest.spyOn(global, 'fetchAndLogExports').mockResolvedValue({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      // Spy on downloadFile to verify it's NOT called
      const downloadFileSpy = jest.spyOn(global, 'downloadFile');
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(console.log).toHaveBeenCalledWith('No Released Export available for download.');
      expect(downloadFileSpy).not.toHaveBeenCalled();
    });
  });
});