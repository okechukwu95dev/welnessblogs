import { 
  fetchData, 
  fetchAndLogExports, 
  downloadFile,
  handleStagedExportDownload,
  handleReleaseExport,
  handleLatestStagedExportDownload,
  handleReleasedExportDownload
} from '@/main/components/ExportMenu/exportFunctions';

// Mock dependencies with proper TypeScript signatures
jest.mock('@/main/utility/FilenameUtils', () => ({
  generateExportFilename: jest.fn().mockImplementation((exportData, stage) => 
    `export-${exportData.id}-${stage}.zip`)
}));

// Set up the document mock properly for TypeScript
const originalDocument = { ...global.document };
const mockAnchor = {
  href: '',
  download: '',
  click: jest.fn()
};

Object.defineProperty(global, 'document', {
  value: {
    ...originalDocument,
    createElement: jest.fn().mockReturnValue(mockAnchor),
    body: {
      appendChild: jest.fn(),
      removeChild: jest.fn()
    }
  },
  writable: true
});

// Mock URL.createObjectURL with proper signature
global.URL.createObjectURL = jest.fn().mockReturnValue('blob:mock-url');

describe('Export Functions', () => {
  let mockClient;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create a mock client for all tests
    mockClient = {
      get: jest.fn(),
      post: jest.fn(),
      put: jest.fn()
    };
  });
  
  describe('fetchData', () => {
    it('should fetch data from URL and return results', async () => {
      // Setup with proper TypeScript types
      const mockResponse = { 
        data: { 
          results: [{ id: 1 }, { id: 2 }],
          next: null 
        } 
      };
      mockClient.get.mockImplementation(() => Promise.resolve(mockResponse));
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/test-url');
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle paginated data', async () => {
      // Setup
      const mockResponse1 = { 
        data: { 
          results: [{ id: 1 }],
          next: '/next-page' 
        } 
      };
      const mockResponse2 = { 
        data: { 
          results: [{ id: 2 }],
          next: null 
        } 
      };
      
      mockClient.get.mockImplementation((url) => {
        if (url === '/test-url') return Promise.resolve(mockResponse1);
        if (url === '/next-page') return Promise.resolve(mockResponse2);
        return Promise.reject(new Error('Unexpected URL'));
      });
      
      // Execute
      const results = await fetchData(mockClient, '/test-url');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledTimes(2);
      expect(results).toEqual([{ id: 1 }, { id: 2 }]);
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.get.mockImplementation(() => 
        Promise.reject(new Error('Network error'))
      );
      
      // Execute & Verify
      const results = await fetchData(mockClient, '/test-url');
      expect(results).toEqual([]);
    });
  });
  
  describe('fetchAndLogExports', () => {
    it('should fetch and filter exports', async () => {
      // Setup
      const mockResults = [
        { id: 1, exportPhase: 'STAGING' },
        { id: 2, exportPhase: 'RELEASE' },
        { id: 3, exportPhase: 'STAGING' }
      ];
      
      // Mock fetchData function with proper implementation
      // Temporarily replace the original function
      const originalFetchData = fetchData;
      // @ts-ignore - Ignore TypeScript for this replacement
      global.fetchData = jest.fn().mockImplementation(() => Promise.resolve(mockResults));
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(result).toEqual({
        latestStagedExport: { id: 3, exportPhase: 'STAGING' },
        latestReleasedExport: { id: 2, exportPhase: 'RELEASE' }
      });
      
      // Restore original
      // @ts-ignore
      global.fetchData = originalFetchData;
    });
    
    it('should handle empty results', async () => {
      // Setup
      const originalFetchData = fetchData;
      // @ts-ignore
      global.fetchData = jest.fn().mockImplementation(() => Promise.resolve([]));
      
      // Execute
      const result = await fetchAndLogExports(mockClient);
      
      // Verify
      expect(result).toEqual({
        latestStagedExport: null,
        latestReleasedExport: null
      });
      
      // Restore original
      // @ts-ignore
      global.fetchData = originalFetchData;
    });
  });
  
  describe('downloadFile', () => {
    it('should download a file', async () => {
      // Setup
      const mockExportData = { id: 1, artifactSource: 'test-source' };
      const blob = new Blob(['test'], { type: 'application/zip' });
      mockClient.get.mockImplementation(() => Promise.resolve({ data: blob }));
      
      // Execute
      await downloadFile(mockClient, 'test-source', mockExportData, 'RELEASE');
      
      // Verify
      expect(mockClient.get).toHaveBeenCalledWith('/export-artifact/test-source/download/', { responseType: 'blob' });
      expect(document.createElement).toHaveBeenCalled();
      expect(global.URL.createObjectURL).toHaveBeenCalled();
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.get.mockImplementation(() => 
        Promise.reject(new Error('Download error'))
      );
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
      
      // Execute
      await downloadFile(mockClient, 'test-source', { id: 1 }, 'STAGING');
      
      // Verify
      expect(consoleSpy).toHaveBeenCalled();
    });
  });
  
  describe('handleStagedExportDownload', () => {
    it('should post to /export/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Staged' } };
      mockClient.post.mockImplementation(() => Promise.resolve(mockResponse));
      
      // Execute
      const result = await handleStagedExportDownload(mockClient);
      
      // Verify
      expect(mockClient.post).toHaveBeenCalledWith('/export/');
      expect(result).toEqual({ id: 1, status: 'Staged' });
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.post.mockImplementation(() => 
        Promise.reject(new Error('Staging error'))
      );
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
      
      // Execute
      await handleStagedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalled();
    });
  });
  
  describe('handleReleaseExport', () => {
    it('should put to /export/{id}/release/ endpoint and return data', async () => {
      // Setup
      const mockResponse = { data: { id: 1, status: 'Released' } };
      mockClient.put.mockImplementation(() => Promise.resolve(mockResponse));
      
      // Execute
      const result = await handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(mockClient.put).toHaveBeenCalledWith('/export/1/release/');
      expect(result).toEqual({ id: 1, status: 'Released' });
    });
    
    it('should handle errors', async () => {
      // Setup
      mockClient.put.mockImplementation(() => 
        Promise.reject(new Error('Release error'))
      );
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});
      
      // Execute
      await handleReleaseExport(mockClient, 1);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalled();
    });
  });
  
  describe('handleLatestStagedExportDownload', () => {
    it('should download the latest staged export', async () => {
      // Setup
      const latestStagedExport = { 
        id: 1, 
        artifactSource: 'test-source',
        exportPhase: 'STAGING'
      };
      
      // Mock both functions we're testing
      const originalFetchAndLogExports = fetchAndLogExports;
      const originalDownloadFile = downloadFile;
      
      // @ts-ignore
      global.fetchAndLogExports = jest.fn().mockImplementation(() => 
        Promise.resolve({
          latestStagedExport,
          latestReleasedExport: null
        })
      );
      
      // @ts-ignore
      global.downloadFile = jest.fn().mockImplementation(() => Promise.resolve());
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(global.fetchAndLogExports).toHaveBeenCalled();
      expect(global.downloadFile).toHaveBeenCalled();
      
      // Restore originals
      // @ts-ignore
      global.fetchAndLogExports = originalFetchAndLogExports;
      // @ts-ignore
      global.downloadFile = originalDownloadFile;
    });
    
    it('should handle case with no staged exports', async () => {
      // Setup
      const originalFetchAndLogExports = fetchAndLogExports;
      
      // @ts-ignore
      global.fetchAndLogExports = jest.fn().mockImplementation(() => 
        Promise.resolve({
          latestStagedExport: null,
          latestReleasedExport: null
        })
      );
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await handleLatestStagedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalled();
      
      // Restore
      // @ts-ignore
      global.fetchAndLogExports = originalFetchAndLogExports;
    });
  });
  
  describe('handleReleasedExportDownload', () => {
    it('should download the latest released export', async () => {
      // Setup
      const latestReleasedExport = { 
        id: 2, 
        artifactSource: 'test-source',
        exportPhase: 'RELEASE'
      };
      
      // Mock both functions
      const originalFetchAndLogExports = fetchAndLogExports;
      const originalDownloadFile = downloadFile;
      
      // @ts-ignore
      global.fetchAndLogExports = jest.fn().mockImplementation(() => 
        Promise.resolve({
          latestStagedExport: null,
          latestReleasedExport
        })
      );
      
      // @ts-ignore
      global.downloadFile = jest.fn().mockImplementation(() => Promise.resolve());
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(global.fetchAndLogExports).toHaveBeenCalled();
      expect(global.downloadFile).toHaveBeenCalled();
      
      // Restore
      // @ts-ignore
      global.fetchAndLogExports = originalFetchAndLogExports;
      // @ts-ignore
      global.downloadFile = originalDownloadFile;
    });
    
    it('should handle case with no released exports', async () => {
      // Setup
      const originalFetchAndLogExports = fetchAndLogExports;
      
      // @ts-ignore
      global.fetchAndLogExports = jest.fn().mockImplementation(() => 
        Promise.resolve({
          latestStagedExport: null,
          latestReleasedExport: null
        })
      );
      
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation(() => {});
      
      // Execute
      await handleReleasedExportDownload(mockClient);
      
      // Verify
      expect(consoleSpy).toHaveBeenCalled();
      
      // Restore
      // @ts-ignore
      global.fetchAndLogExports = originalFetchAndLogExports;
    });
  });
});